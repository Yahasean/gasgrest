<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D 多球平衡遊戲 Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0d0d1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0ff;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        #game-container {
            position: relative;
            width: 90vmin;
            height: 90vmin;
            background: linear-gradient(135deg, #1a1a3a 0%, #2b102b 100%);
            border: 8px solid;
            border-image: linear-gradient(45deg, #00ffff, #ff00ff) 1;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.3), 0 0 80px rgba(255, 0, 255, 0.2);
            border-radius: 4px; /* Three.js 畫布通常是矩形，用這個微調 */
            overflow: hidden;
        }
        #three-canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #ui-layer {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 100;
            width: 100%;
        }
        h2 {
            margin: 0;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0,255,255,0.8);
        }
        .info {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }
        #start-btn {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 18px;
            background: rgba(0, 188, 212, 0.8);
            color: white;
            border: 2px solid #00ffff;
            border-radius: 25px;
            cursor: pointer;
            pointer-events: auto;
            display: none; /* 預設隱藏，JS 檢查後顯示 */
            backdrop-filter: blur(5px);
        }
        #debug-info {
            margin-top: 10px;
            font-family: monospace;
            color: #00ff00;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="three-canvas"></canvas>
        <div id="ui-layer">
            <h2 id="status">載入完成！請點擊開始</h2>
            <p class="info">電腦：方向鍵 | 手機：傾斜</p>
            <div id="debug-info">等待操作...</div>
            <button id="start-btn">啟動陀螺儀</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 等待所有資源載入後再執行 ---
        window.onload = function() {
            if (typeof THREE === 'undefined' || typeof Matter === 'undefined') {
                document.getElementById('status').innerText = "錯誤：程式庫載入失敗，請重新整理";
                return;
            }
            initGame();
        };

        function initGame() {
            // --- 變數宣告 ---
            const container = document.getElementById('game-container');
            const threeCanvas = document.getElementById('three-canvas');
            const debugInfo = document.getElementById('debug-info');
            const startBtn = document.getElementById('start-btn');
            const statusText = document.getElementById('status');
            
            let scene, camera, renderer;
            const threeBalls = []; 
            let engine, world;
            const matterBalls = [];

            // 陀螺儀數據
            let tiltX = 0;
            let tiltY = 0;
            const keys = {};

            // --- 1. 初始化 THREE.js 場景 ---
            function initThree() {
                scene = new THREE.Scene();
                
                // 相機設定
                camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(0, 0, 600); // 拉高相機距離
                camera.lookAt(0, 0, 0);

                // 渲染器設定
                renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);

                // 燈光
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const spotLight = new THREE.SpotLight(0xffffff, 1);
                spotLight.position.set(100, 100, 500);
                spotLight.angle = Math.PI / 4;
                spotLight.penumbra = 0.1;
                scene.add(spotLight);

                // 建立透明地板平面 (只為了接收陰影或視覺參考，可選)
                // 這裡我們主要依賴 CSS 背景，Three.js 只負責球
            }

            // --- 2. 初始化 Matter.js 物理 ---
            function initPhysics() {
                const Engine = Matter.Engine,
                      Bodies = Matter.Bodies,
                      World = Matter.World;

                engine = Engine.create();
                world = engine.world;
                engine.gravity.y = 0; // 關閉重力，由陀螺儀控制

                const width = container.clientWidth;
                const height = container.clientHeight;
                const wallThick = 100;

                // 建立牆壁 (看不見的物理牆)
                const walls = [
                    Bodies.rectangle(width/2, -wallThick/2, width, wallThick, { isStatic: true }), // 上
                    Bodies.rectangle(width/2, height + wallThick/2, width, wallThick, { isStatic: true }), // 下
                    Bodies.rectangle(-wallThick/2, height/2, wallThick, height, { isStatic: true }), // 左
                    Bodies.rectangle(width + wallThick/2, height/2, wallThick, height, { isStatic: true }) // 右
                ];
                World.add(world, walls);

                // 建立球體
                const ballColors = [0xff0055, 0x00ffaa, 0xffff00, 0x00ccff, 0xaa00ff];
                
                for(let i=0; i<6; i++) {
                    const radius = 25 + Math.random() * 15; // 隨機半徑 25~40
                    const x = Math.random() * (width - 100) + 50;
                    const y = Math.random() * (height - 100) + 50;
                    
                    // 物理球
                    const mBall = Bodies.circle(x, y, radius, {
                        restitution: 0.9, // 高彈性
                        friction: 0.001,  // 低摩擦
                        frictionAir: 0.02, // 空氣阻力，讓球不要永遠停不下來
                        density: 0.05
                    });
                    World.add(world, mBall);
                    matterBalls.push(mBall);

                    // 3D 球
                    const geometry = new THREE.SphereGeometry(radius, 32, 32);
                    const material = new THREE.MeshPhongMaterial({
                        color: ballColors[i % ballColors.length],
                        shininess: 100,
                        specular: 0x444444
                    });
                    const tBall = new THREE.Mesh(geometry, material);
                    scene.add(tBall);
                    threeBalls.push(tBall);
                }
            }

            // --- 3. 遊戲循環 ---
            function animate() {
                requestAnimationFrame(animate);

                // 1. 更新物理引擎
                Matter.Engine.update(engine, 1000 / 60);

                // 2. 計算施力 (陀螺儀 + 鍵盤)
                let fx = 0, fy = 0;
                const forceScale = 0.0002; // 力道係數

                // 鍵盤
                if(keys['ArrowUp']) fy -= 1;
                if(keys['ArrowDown']) fy += 1;
                if(keys['ArrowLeft']) fx -= 1;
                if(keys['ArrowRight']) fx += 1;

                // 陀螺儀
                fx += tiltX * 0.1; 
                fy += tiltY * 0.1;

                // 對所有球施力
                matterBalls.forEach(ball => {
                    Matter.Body.applyForce(ball, ball.position, {
                        x: fx * forceScale * ball.mass,
                        y: fy * forceScale * ball.mass
                    });
                });

                // 3. 同步 物理 -> 3D
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                for(let i=0; i<matterBalls.length; i++) {
                    const mBall = matterBalls[i];
                    const tBall = threeBalls[i];

                    // Matter.js (0,0 在左上) -> Three.js (0,0 在中心)
                    tBall.position.x = mBall.position.x - width / 2;
                    tBall.position.y = -(mBall.position.y - height / 2); // Y軸反轉
                    
                    // 簡單的旋轉效果 (根據速度)
                    tBall.rotation.x += mBall.velocity.y * 0.05;
                    tBall.rotation.z -= mBall.velocity.x * 0.05;
                }

                // 渲染
                renderer.render(scene, camera);
            }

            // --- 4. 事件監聽 ---
            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                renderer.setSize(w, h);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                // 注意：物理牆壁沒重新調整，手機轉向可能會有些問題，建議鎖定直向
            });

            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);

            // iOS 權限按鈕處理
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                startBtn.style.display = 'inline-block';
                startBtn.addEventListener('click', () => {
                    DeviceOrientationEvent.requestPermission()
                        .then(resp => {
                            if (resp === 'granted') {
                                startBtn.style.display = 'none';
                                statusText.innerText = "遊戲開始！";
                                window.addEventListener('deviceorientation', handleOrientation);
                            } else {
                                alert("需要權限才能遊玩");
                            }
                        })
                        .catch(console.error);
                });
            } else {
                // Android / PC
                statusText.innerText = "遊戲開始！(直接搖晃)";
                window.addEventListener('deviceorientation', handleOrientation);
            }

            function handleOrientation(event) {
                const x = event.gamma; // 左右 -90 ~ 90
                const y = event.beta;  // 前後 -180 ~ 180
                if (x !== null && y !== null) {
                    // 限制角度，避免力道過大
                    tiltX = Math.max(-40, Math.min(40, x));
                    tiltY = Math.max(-40, Math.min(40, y));
                    debugInfo.innerText = `X: ${tiltX.toFixed(0)} | Y: ${tiltY.toFixed(0)}`;
                }
            }

            // 啟動
            initThree();
            initPhysics();
            animate();
        }
    </script>
</body>
</html>
