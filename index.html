<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>液體模擬 - 掌中水杯</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            font-family: 'Segoe UI', sans-serif;
        }

        /* 這是液體效果的核心：容器 */
        #fluid-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 關鍵濾鏡：先模糊，再加強對比，讓模糊邊緣變銳利，產生沾黏感 */
            filter: url('#goo'); 
            background: transparent;
            z-index: 2;
        }

        canvas {
            display: block;
        }

        /* 背景裝飾 - 模擬玻璃杯後的深海光影 */
        #background-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a2a6c, #b21f1f, #fdbb2d); /* 預設備用 */
            background: linear-gradient(180deg, #050505 0%, #0a1525 100%);
            z-index: 1;
        }

        /* 模擬玻璃反光 */
        #glass-reflection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 40%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
            z-index: 10;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.6);
        }

        #start-btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 18px;
            background: rgba(0, 200, 255, 0.2);
            color: #00ffff;
            border: 1px solid #00ffff;
            border-radius: 30px;
            cursor: pointer;
            pointer-events: auto;
            display: none;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: 0.3s;
        }
        #start-btn:hover {
            background: rgba(0, 200, 255, 0.4);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }

    </style>
</head>
<body>

    <div id="background-layer"></div>
    <div id="glass-reflection"></div>

    <div id="ui-layer">
        <h2 id="status">液體填充中...</h2>
        <button id="start-btn">注入液體 (啟動感測器)</button>
    </div>

    <svg style="visibility: hidden; position: absolute;" width="0" height="0" xmlns="http://www.w3.org/2000/svg" version="1.1">
        <defs>
            <filter id="goo">
                <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
                <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 18 -7" result="goo" />
                <feComposite in="SourceGraphic" in2="goo" operator="atop"/>
            </filter>
        </defs>
    </svg>

    <div id="fluid-container">
        <canvas id="world"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        window.addEventListener('load', init);

        function init() {
            const Engine = Matter.Engine,
                  Render = Matter.Render,
                  Runner = Matter.Runner,
                  Composites = Matter.Composites,
                  Common = Matter.Common,
                  MouseConstraint = Matter.MouseConstraint,
                  Mouse = Matter.Mouse,
                  World = Matter.World,
                  Bodies = Matter.Bodies,
                  Body = Matter.Body;

            // 1. 建立引擎
            const engine = Engine.create();
            const world = engine.world;

            // 2. 建立渲染器 (自定義渲染以獲得液體顏色)
            const container = document.getElementById('fluid-container');
            const canvas = document.getElementById('world');
            
            // 設定 Canvas 大小
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // 使用 Matter.Render 作為基礎，但我們會修改樣式
            const render = Render.create({
                element: container,
                canvas: canvas,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    background: 'transparent', // 透明背景
                    wireframes: false, // 關閉線框模式
                    showAngleIndicator: false
                }
            });

            // 3. 添加牆壁 (邊界)
            // 為了讓水看起來像在全螢幕玻璃杯裡，牆壁要貼齊螢幕邊緣
            let walls = [];
            function createWalls() {
                World.remove(world, walls); // 移除舊牆壁
                const thickness = 100; 
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                walls = [
                    Bodies.rectangle(width/2, -thickness/2, width, thickness, { isStatic: true, render: { visible: false } }), // 上
                    Bodies.rectangle(width/2, height + thickness/2, width, thickness, { isStatic: true, render: { visible: false } }), // 下
                    Bodies.rectangle(width + thickness/2, height/2, thickness, height, { isStatic: true, render: { visible: false } }), // 右
                    Bodies.rectangle(-thickness/2, height/2, thickness, height, { isStatic: true, render: { visible: false } }) // 左
                ];
                World.add(world, walls);
            }
            createWalls();

            // 4. 生成「液體」粒子
            // 使用堆疊 (Stack) 生成大量小球
            const particleSize = 10; // 粒子大小 (配合 SVG 濾鏡調整)
            const cols = 15; 
            const rows = 15;
            
            const fluid = Composites.stack(
                window.innerWidth / 2 - 100, // 起始 X
                window.innerHeight / 2 - 100, // 起始 Y
                cols, rows, // 行列數
                0, 0, // 間距
                function(x, y) {
                    return Bodies.circle(x, y, particleSize, {
                        friction: 0.005,
                        restitution: 0.5, // 稍微有點彈性
                        density: 0.04,
                        render: {
                            // 液體顏色：這裡是關鍵
                            // 為了配合濾鏡，我們用亮藍色/青色
                            fillStyle: '#00eaff', 
                            strokeStyle: 'transparent'
                        }
                    });
                }
            );
            World.add(world, fluid);

            // 5. 啟動引擎
            Render.run(render);
            const runner = Runner.create();
            Runner.run(runner, engine);

            // 6. 陀螺儀控制 (核心邏輯)
            const startBtn = document.getElementById('start-btn');
            const statusText = document.getElementById('status');

            // 處理視窗縮放
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                render.canvas.width = window.innerWidth;
                render.canvas.height = window.innerHeight;
                createWalls();
            });

            // 授權與開始
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                statusText.innerText = "準備就緒";
                startBtn.style.display = 'inline-block';
                
                startBtn.addEventListener('click', () => {
                    DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response == 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            startBtn.style.display = 'none';
                            statusText.style.display = 'none'; // 隱藏文字，沉浸體驗
                        }
                    })
                    .catch(console.error);
                });
            } else {
                statusText.innerText = "請晃動設備";
                window.addEventListener('deviceorientation', handleOrientation);
                // 自動隱藏UI
                setTimeout(() => {
                    startBtn.style.display = 'none';
                    statusText.style.display = 'none';
                }, 2000);
            }

            // 重力映射函式
            function handleOrientation(event) {
                const gamma = event.gamma; // 左右傾斜 (-90 ~ 90)
                const beta = event.beta;   // 前後傾斜 (-180 ~ 180)

                if (gamma === null || beta === null) return;

                // --- 重力計算邏輯 ---
                // 目標：模擬直立拿著手機。
                // 當手機直立時 (Beta ~90)，重力應該向下 (Y = 1)。
                // 當手機向右倒 (Gamma > 0)，重力向右 (X > 0)。
                
                // 限制重力最大值，避免移動過快
                const gravityScale = 1;

                // X 軸重力直接對應 Gamma (左右傾斜)
                // 這裡除以 90 是為了歸一化到 -1 ~ 1
                let gravityX = Math.min(Math.max(gamma / 45, -1), 1);

                // Y 軸重力對應 Beta。
                // 直立時 Beta=90 -> Gravity Y=1 (向下)
                // 平放時 Beta=0  -> Gravity Y=0
                // 倒立時 Beta=-90 -> Gravity Y=-1 (向上)
                // 我們主要希望它在直立附近運作，所以用 sin 函數或線性映射
                
                // 簡單映射：假設使用者主要在 45~135 度之間操作
                // (Beta - 90) / 90 
                // 但為了簡單，我們直接讓 Beta 控制 Y 軸
                // 注意：Matter.js 的 Y 往下是正
                let gravityY = Math.min(Math.max(beta / 45, -1), 1); 

                // 如果是 Android，座標系可能相反，這裡預設 iOS/Standard Web
                // 如果覺得方向反了，可以在這裡加負號
                
                engine.gravity.x = gravityX * gravityScale;
                engine.gravity.y = gravityY * gravityScale;
            }
            
            // 加入滑鼠/觸控互動 (可以用手攪動水)
            const mouse = Mouse.create(render.canvas);
            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.2,
                    render: { visible: false }
                }
            });
            World.add(world, mouseConstraint);
            render.mouse = mouse; // 讓滑鼠座標同步
        }
    </script>
</body>
</html>
