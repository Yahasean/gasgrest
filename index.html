<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D 玻璃音箱</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            /* 漸層背景 */
            background: radial-gradient(circle at center, #1a1a2e, #000000);
            touch-action: none;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas { display: block; }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #start-btn {
            pointer-events: auto;
            padding: 15px 40px;
            font-size: 20px;
            color: white;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-weight: bold;
            letter-spacing: 2px;
            text-transform: uppercase;
            transition: transform 0.1s;
            box-shadow: 0 0 20px rgba(0, 100, 255, 0.3);
        }
        #start-btn:active { transform: scale(0.95); }

        #status-text {
            margin-top: 20px;
            color: #aaa;
            font-size: 14px;
            text-shadow: 0 0 5px black;
        }

        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #555;
            font-size: 12px;
            font-family: monospace;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <button id="start-btn">ENTER 3D BOX</button>
        <div id="status-text">建議開啟聲音 • 搖晃手機互動</div>
    </div>
    <div id="debug-info"></div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- 1. 音效系統 (清脆風鈴版) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let isAudioReady = false;

        function initAudio() {
            audioCtx = new AudioContext();
            isAudioReady = true;
        }

        function playChime(velocity) {
            if (!isAudioReady || velocity < 1.5) return;

            const t = audioCtx.currentTime;
            
            // 碰撞力道決定音量
            const volume = Math.min(velocity * 0.05, 0.6);

            // 建立兩個震盪器來模擬金屬/玻璃的和聲
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            // 音調隨機化：讓聲音不會太單調
            // 基礎頻率高一點 (2000Hz - 3000Hz) 才有清脆感
            const baseFreq = 2200 + Math.random() * 500;

            osc1.type = 'sine';
            osc1.frequency.value = baseFreq; // 主音

            osc2.type = 'sine';
            osc2.frequency.value = baseFreq * 1.5; // 泛音 (5度音)
            
            // 連接
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // 音量包絡 (Envelope) - 像敲擊聲
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(volume, t + 0.01); // 快速起音 (Attack)
            gainNode.gain.exponentialRampToValueAtTime(0.001, t + 1.5); // 長長的餘韻 (Decay)

            osc1.start(t);
            osc2.start(t);
            osc1.stop(t + 1.5);
            osc2.stop(t + 1.5);
        }

        // --- 2. 3D 場景設定 ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        
        // 相機位置設定
        const fov = 45;
        const cameraZ = 20; // 相機距離
        const camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, cameraZ);

        // 燈光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        // 藍色點光，增加科技感
        const pointLight = new THREE.PointLight(0x0088ff, 100, 50);
        pointLight.position.set(-5, -5, 5);
        scene.add(pointLight);

        // --- 3. 物理世界 (Cannon-es) ---
        const world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0), // 初始重力向下
        });
        
        // 物理材質
        const wallMaterial = new CANNON.Material('wall');
        const ballMaterial = new CANNON.Material('ball');
        
        // 設定碰撞行為 (高反彈)
        const wallBallContact = new CANNON.ContactMaterial(wallMaterial, ballMaterial, {
            friction: 0.0, // 非常滑，像玻璃
            restitution: 0.6 // 彈性
        });
        world.addContactMaterial(wallBallContact);

        const ballBallContact = new CANNON.ContactMaterial(ballMaterial, ballMaterial, {
            friction: 0.0,
            restitution: 0.7
        });
        world.addContactMaterial(ballBallContact);

        // --- 4. 牆壁與邊界邏輯 (核心：視錐體計算) ---
        const wallBodies = []; // 儲存牆壁物理體

        function createWalls() {
            // 移除舊牆壁
            wallBodies.forEach(b => world.removeBody(b));
            wallBodies.length = 0;

            // 計算在 Z=0 平面上的可視寬高
            // Math.tan 需要弧度
            const aspect = window.innerWidth / window.innerHeight;
            const vFov = fov * Math.PI / 180;
            const visibleHeight = 2 * Math.tan(vFov / 2) * cameraZ;
            const visibleWidth = visibleHeight * aspect;

            const w = visibleWidth / 2;
            const h = visibleHeight / 2;
            const depth = 3; // 箱子的深度 (Z軸厚度)

            // 建立 6 面牆 (前後左右上下)
            const thickness = 5;
            
            // 牆壁參數陣列: [位置, 旋轉軸, 旋轉角度, 尺寸]
            // Cannon 的 Plane 是無限大的，但用 Box 比較好控制邊界
            const wallsData = [
                { pos: [0, h + thickness/2, 0], size: [w + thickness, thickness, depth + thickness] }, // 上
                { pos: [0, -h - thickness/2, 0], size: [w + thickness, thickness, depth + thickness] }, // 下
                { pos: [-w - thickness/2, 0, 0], size: [thickness, h + thickness, depth + thickness] }, // 左
                { pos: [w + thickness/2, 0, 0], size: [thickness, h + thickness, depth + thickness] }, // 右
                { pos: [0, 0, -depth/2 - thickness/2], size: [w + thickness, h + thickness, thickness] }, // 後
                { pos: [0, 0, depth/2 + thickness/2], size: [w + thickness, h + thickness, thickness] } // 前 (透明玻璃)
            ];

            wallsData.forEach(data => {
                const shape = new CANNON.Box(new CANNON.Vec3(data.size[0], data.size[1], data.size[2]));
                const body = new CANNON.Body({
                    mass: 0, // 靜態
                    material: wallMaterial
                });
                body.addShape(shape);
                body.position.set(data.pos[0], data.pos[1], data.pos[2]);
                world.addBody(body);
                wallBodies.push(body);
            });
        }

        // --- 5. 球體生成 ---
        const balls = [];
        const ballMeshes = [];
        const ballColors = [0xff0055, 0x00ccff, 0xffcc00, 0xaa00ff, 0x00ffaa];

        function createBalls() {
            const count = 60;
            const ballRadius = 0.6; // 在 Three.js 單位中，這大概對應螢幕上的視覺大小

            const geometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            
            // 使用 MeshPhysicalMaterial 模擬亮面塑膠/玻璃質感
            const baseMaterial = new THREE.MeshPhysicalMaterial({
                metalness: 0.1,
                roughness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
            });

            for(let i=0; i<count; i++) {
                // 物理體
                const shape = new CANNON.Sphere(ballRadius);
                const body = new CANNON.Body({
                    mass: 1,
                    material: ballMaterial,
                    linearDamping: 0.3, // 阻尼，避免永遠停不下來
                    angularDamping: 0.3
                });
                
                // 隨機位置 (在箱子內)
                body.position.set(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 2 // Z軸隨機
                );
                world.addBody(body);
                balls.push(body);

                // 監聽碰撞播放聲音
                body.addEventListener("collide", (e) => {
                    // 取得相對撞擊速度
                    const relativeVelocity = e.contact.getImpactVelocityAlongNormal();
                    if(Math.abs(relativeVelocity) > 2) {
                        playChime(Math.abs(relativeVelocity));
                    }
                });

                // 網格 (Mesh)
                const material = baseMaterial.clone();
                material.color.setHex(ballColors[Math.floor(Math.random() * ballColors.length)]);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                ballMeshes.push(mesh);
            }
        }

        // --- 6. 互動控制 (重力 + 搖晃) ---
        let lastAcc = {x:0, y:0, z:0};
        
        function handleOrientation(e) {
            // 映射 DeviceOrientation 到 3D 重力向量
            // 手機直立：Y = -9.8
            // 手機右傾：X = 9.8
            // 手機平放：Z = -9.8 (背面朝下)
            
            // 這裡我們主要控制 X 和 Y，Z 軸稍微給一點傾向背面，讓球貼著背板比較好看
            // 或者讓 Z 軸也隨手機傾斜改變，實現真實 3D 滾動
            
            const g = 9.82;
            const gamma = e.gamma || 0; // 左-90 ~ 右90
            const beta = e.beta || 0;   // 後-180 ~ 前180

            // 簡單的三角函數轉換 (近似值)
            const radX = beta * Math.PI / 180;
            const radY = gamma * Math.PI / 180;

            // 計算重力向量
            world.gravity.set(
                Math.sin(radY) * g * 2, // X 加強一點
                Math.sin(radX) * -g * 2, // Y 加強一點 (注意 Canvas Y軸向上，但物理向下)
                -5 // 給一個恆定的 Z 軸重力，傾向於讓球靠向「背板」或「螢幕」? 
                   // 設為 0 讓它完全自由，或 -2 讓它稍微向後靠
            );
        }

        function handleMotion(e) {
            const acc = e.accelerationIncludingGravity || e.acceleration;
            if(!acc) return;

            const dx = acc.x - lastAcc.x;
            const dy = acc.y - lastAcc.y;
            const dz = acc.z - lastAcc.z;
            const totalDelta = Math.abs(dx) + Math.abs(dy) + Math.abs(dz);

            // 搖晃偵測
            if (totalDelta > 20) {
                // 施加隨機衝量 (爆炸效果)
                balls.forEach(body => {
                    const force = 10;
                    body.applyImpulse(
                        new CANNON.Vec3(
                            (Math.random()-0.5) * force,
                            (Math.random()-0.5) * force,
                            (Math.random()-0.5) * force * 0.5 // Z軸力道小一點
                        ),
                        body.position
                    );
                });
                
                // 震動
                if(navigator.vibrate) navigator.vibrate(100);
            }
            lastAcc = {x:acc.x, y:acc.y, z:acc.z};
        }


        // --- 7. 渲染循環 ---
        const timeStep = 1 / 60;
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            
            // 更新物理世界
            world.step(timeStep, dt, 3);

            // 同步物理位置到視覺網格
            for (let i = 0; i < balls.length; i++) {
                ballMeshes[i].position.copy(balls[i].position);
                ballMeshes[i].quaternion.copy(balls[i].quaternion);
            }

            renderer.render(scene, camera);
        }

        // --- 啟動邏輯 ---
        const startBtn = document.getElementById('start-btn');
        const uiLayer = document.getElementById('ui-layer');

        function start() {
            uiLayer.style.display = 'none';
            
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('deviceorientation', handleOrientation);
            window.addEventListener('devicemotion', handleMotion);

            createWalls(); // 根據螢幕建立邊界
            createBalls();
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            createWalls(); // 視窗變動時重建牆壁
        }

        startBtn.addEventListener('click', () => {
            initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();

            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(r => { if(r === 'granted') start(); })
                    .catch(e => start());
            } else {
                start();
            }
        });

    </script>
</body>
</html>
