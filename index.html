<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2.5D 玻璃擬真版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            touch-action: none;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas { display: block; }

        /* --- 假玻璃反光層 (Glass Glare Overlay) --- */
        #glass-overlay {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            pointer-events: none; /* 讓點擊穿透 */
            z-index: 50;
            /* 製作一道斜向的亮光 */
            background: linear-gradient(
                115deg, 
                rgba(255,255,255,0) 40%, 
                rgba(255,255,255,0.05) 45%, 
                rgba(255,255,255,0.15) 50%, 
                rgba(255,255,255,0.05) 55%, 
                rgba(255,255,255,0) 60%
            );
            /* 混合模式讓它看起來像光 */
            mix-blend-mode: overlay;
            transition: transform 0.1s ease-out;
        }

        /* --- 控制面板 --- */
        #control-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: rgba(20, 25, 35, 0.85);
            color: white;
            padding: 15px 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.15);
            transition: transform 0.3s ease;
        }

        #control-panel.collapsed { transform: translateY(-100%); }

        #toggle-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 101;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255,255,255,0.2);
            width: 42px;
            height: 42px;
            border-radius: 50%;
            color: #00ffff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .control-group {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .control-group label { width: 50px; font-size: 12px; color: #ccc; }
        .control-group input {
            flex: 1; margin: 0 15px; cursor: pointer; height: 4px;
            border-radius: 2px; appearance: none; background: rgba(255,255,255,0.2);
        }
        .control-group input::-webkit-slider-thumb {
            appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: #00ffff; box-shadow: 0 0 8px #00ffff;
        }
        .control-group span { width: 30px; text-align: right; font-size: 12px; color: #00ffff; }

        /* 啟動頁面 */
        #start-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; justify-content: center; align-items: center;
            z-index: 200; flex-direction: column;
        }
        #start-btn {
            padding: 18px 50px; font-size: 18px;
            background: transparent; border: 2px solid #00ffff; color: #00ffff;
            border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        }

        #fx-text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 70px; font-weight: 900; color: white;
            opacity: 0; pointer-events: none; z-index: 60;
            text-shadow: 0 0 30px cyan; transition: opacity 0.1s;
        }
    </style>
</head>
<body>

    <div id="glass-overlay"></div>

    <div id="start-overlay">
        <button id="start-btn">Enter Deep Box</button>
        <p style="color:#666; margin-top:20px; font-size:12px;">Stereo Sound • Glass Reflection</p>
    </div>

    <div id="fx-text">CRASH!</div>
    <button id="toggle-btn">⚙️</button>

    <div id="control-panel">
        <div class="control-group">
            <label>數量</label>
            <input type="range" id="input-count" min="10" max="120" value="50" step="5">
            <span id="val-count">50</span>
        </div>
        <div class="control-group">
            <label>大小</label>
            <input type="range" id="input-size" min="15" max="50" value="32" step="1">
            <span id="val-size">32</span>
        </div>
        <div class="control-group">
            <label>隨機</label>
            <input type="range" id="input-random" min="0" max="100" value="40" step="5">
            <span id="val-random">40</span>
        </div>
        <div class="control-group">
            <label>重力</label>
            <input type="range" id="input-gravity" min="0" max="3" value="1" step="0.1">
            <span id="val-gravity">1</span>
        </div>
    </div>

    <canvas id="world"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // ==========================================
        // 1. 水晶音效 (Crystal Chime)
        // ==========================================
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let isAudioReady = false;

        function initAudio() {
            audioCtx = new AudioContext();
            isAudioReady = true;
        }

        function playCrystalSound(intensity) {
            if (!isAudioReady || intensity < 1.5) return;

            const t = audioCtx.currentTime;
            const gain = audioCtx.createGain();
            gain.connect(audioCtx.destination);

            const vol = Math.min(intensity * 0.05, 0.4);
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(vol, t + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 2.0); // 長尾音

            // FM 合成：讓聲音像敲擊玻璃
            const carrier = audioCtx.createOscillator();
            const modulator = audioCtx.createOscillator();
            const modGain = audioCtx.createGain();

            const freq = 1500 + Math.random() * 1500; // 基礎頻率

            carrier.frequency.value = freq;
            carrier.type = 'sine';

            modulator.frequency.value = freq * 1.4; // 非整數倍泛音
            modulator.type = 'sine';

            modGain.gain.value = 500 * intensity; // 調變深度隨力道改變

            modulator.connect(modGain);
            modGain.connect(carrier.frequency);
            carrier.connect(gain);

            carrier.start(t);
            modulator.start(t);
            carrier.stop(t + 2.0);
            modulator.stop(t + 2.0);
        }

        // ==========================================
        // 2. 物理引擎 (Matter.js)
        // ==========================================
        const Engine = Matter.Engine,
              World = Matter.World,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Events = Matter.Events;

        const engine = Engine.create();
        const world = engine.world;
        engine.gravity.scale = 0.001;
        engine.gravity.y = 1;

        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');
        
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        let balls = [];
        let walls = [];
        // 霓虹水晶色系
        const colors = ['#00ffff', '#ff00ff', '#ffffff', '#0088ff', '#aa00ff'];

        let config = {
            count: 50, baseSize: 32, randomness: 40, gravity: 1
        };

        // --- 粒子特效系統 ---
        let particles = [];
        function spawnParticles(x, y, force) {
            const count = Math.min(Math.floor(force * 1.5), 8);
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random()-0.5) * 5,
                    vy: (Math.random()-0.5) * 5,
                    life: 1.0,
                    size: Math.random() * 3 + 1,
                    color: 'rgba(255, 255, 255,'
                });
            }
        }

        function renderParticles() {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.life -= 0.03;
                if(p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.fillStyle = p.color + p.life + ')';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        // --- 牆壁 ---
        function createWalls() {
            World.remove(world, walls);
            walls = [];
            const thick = 200;
            const opts = { isStatic: true, friction: 0, restitution: 0.8, render: { visible: false } };
            walls.push(
                Bodies.rectangle(width/2, -thick/2, width*2, thick, opts),
                Bodies.rectangle(width/2, height+thick/2, width*2, thick, opts),
                Bodies.rectangle(-thick/2, height/2, thick, height*2, opts),
                Bodies.rectangle(width+thick/2, height/2, thick, height*2, opts)
            );
            World.add(world, walls);
        }

        // --- 球體 ---
        function rebuildBalls() {
            World.remove(world, balls);
            balls = [];
            const randFactor = config.randomness / 100;

            for(let i = 0; i < config.count; i++) {
                const scale = (1 - randFactor) + (Math.random() * 2 * randFactor);
                let r = config.baseSize * scale;
                r = Math.max(10, r);

                const x = Math.random() * (width - 100) + 50;
                const y = Math.random() * (height * 0.6) + 50;

                const ball = Bodies.circle(x, y, r, {
                    restitution: 0.75, friction: 0.001, frictionAir: 0.002, density: 0.002,
                    render: { fillStyle: colors[Math.floor(Math.random() * colors.length)] }
                });
                balls.push(ball);
            }
            World.add(world, balls);
        }

        // 碰撞 -> 音效 + 粒子
        Events.on(engine, 'collisionStart', (e) => {
            e.pairs.forEach(pair => {
                const speed = pair.bodyA.speed + pair.bodyB.speed;
                if(speed > 2) {
                    playCrystalSound(speed);
                    
                    // 計算碰撞點
                    const cx = (pair.bodyA.position.x + pair.bodyB.position.x) / 2;
                    const cy = (pair.bodyA.position.y + pair.bodyB.position.y) / 2;
                    
                    // 只有在夠大力時產生粒子，且只在球球之間產生(有半徑屬性)
                    if(pair.bodyA.circleRadius && pair.bodyB.circleRadius) {
                         spawnParticles(cx, cy, speed);
                    }
                }
            });
        });

        // ==========================================
        // 3. 渲染循環 (Render Loop)
        // ==========================================
        
        // 用於視差背景的偏移量
        let parallaxX = 0;
        let parallaxY = 0;

        function render() {
            Engine.update(engine, 1000 / 60);
            ctx.clearRect(0, 0, width, height);

            // --- 1. 視差背景 (Parallax Background) ---
            // 模擬遠處的網格，移動速度比球慢，方向相反
            ctx.save();
            ctx.translate(width/2 + parallaxX, height/2 + parallaxY);
            
            // 畫背景深色漸層
            const bgGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, Math.max(width, height));
            bgGrad.addColorStop(0, '#151525');
            bgGrad.addColorStop(1, '#020205');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(-width, -height, width*2, height*2);

            // 畫網格線
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            ctx.beginPath();
            // 垂直線
            for(let x = -width; x < width; x += gridSize) {
                ctx.moveTo(x, -height); ctx.lineTo(x, height);
            }
            // 水平線
            for(let y = -height; y < height; y += gridSize) {
                ctx.moveTo(-width, y); ctx.lineTo(width, y);
            }
            ctx.stroke();
            ctx.restore();


            // --- 2. 繪製球體 (Shadow + Sphere) ---
            balls.forEach(b => {
                const x = b.position.x;
                const y = b.position.y;
                const r = b.circleRadius;

                // A. 懸浮陰影 (Drop Shadow) - 模擬深度
                // 陰影稍微偏右下，並且模糊，讓球看起來浮起來
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                // 陰影偏移量隨半徑變大 (越大顆浮越高的感覺)
                const offset = r * 0.2;
                ctx.ellipse(x + offset, y + offset, r, r * 0.8, 0, 0, Math.PI*2);
                ctx.fill();
            });

            // B. 球體本體
            balls.forEach(b => {
                const x = b.position.x;
                const y = b.position.y;
                const r = b.circleRadius;

                // 3D 球體漸層
                const grad = ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
                grad.addColorStop(0, adjustColor(b.render.fillStyle, 120)); // Highlight
                grad.addColorStop(0.4, b.render.fillStyle); // Base
                grad.addColorStop(1, adjustColor(b.render.fillStyle, -60)); // Shadow
                
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI*2);
                ctx.fillStyle = grad;
                ctx.fill();

                // 玻璃反光 (Rim Light & Specular)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.ellipse(x - r*0.35, y - r*0.35, r*0.2, r*0.12, Math.PI/4, 0, Math.PI*2);
                ctx.fill();
                
                // 邊緣光
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            });

            // --- 3. 繪製粒子 ---
            renderParticles();

            requestAnimationFrame(render);
        }

        function adjustColor(color, amount) {
            return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
        }

        // ==========================================
        // 4. 感測器邏輯
        // ==========================================
        const glassOverlay = document.getElementById('glass-overlay');
        const fxText = document.getElementById('fx-text');
        let lastAcc = {x:0, y:0};
        let shakeCooldown = false;

        function handleOrientation(e) {
            if (e.gamma === null) return;

            // 1. 物理重力
            const scale = config.gravity * 0.001; 
            engine.gravity.scale = scale;
            const gx = Math.min(Math.max(e.gamma / 45, -1), 1);
            const gy = Math.min(Math.max(e.beta / 45, -1), 1);
            engine.gravity.x = gx;
            engine.gravity.y = gy;

            // 2. 視差背景 (Parallax) - 背景反向移動
            parallaxX = -gx * 30; // 最大偏移 30px
            parallaxY = -gy * 30;

            // 3. 玻璃反光移動 (Glare Movement)
            // 根據手機角度移動 overlay 的位置
            const transX = gx * 50; // 50% 的位移
            const transY = gy * 50;
            glassOverlay.style.transform = `translate(${transX}px, ${transY}px)`;
        }

        function handleMotion(e) {
            const acc = e.accelerationIncludingGravity || e.acceleration;
            if(!acc) return;
            
            const dx = acc.x - lastAcc.x;
            const dy = acc.y - lastAcc.y;
            const total = Math.abs(dx) + Math.abs(dy);

            // 慣性
            if(total > 1) {
                balls.forEach(b => {
                    Body.applyForce(b, b.position, {
                        x: -dx * 0.0005 * b.mass,
                        y: -dy * 0.0005 * b.mass
                    });
                });
            }

            // Shake
            if(!shakeCooldown && total > 25) {
                shakeCooldown = true;
                fxText.style.opacity = 1;
                fxText.innerText = ["CRASH!", "BOOM!", "POW!"][Math.floor(Math.random()*3)];
                setTimeout(()=>fxText.style.opacity=0, 300);
                setTimeout(()=>shakeCooldown=false, 300);
                
                if(navigator.vibrate) navigator.vibrate(150);
                
                balls.forEach(b => {
                    Body.applyForce(b, b.position, {
                        x: (Math.random()-0.5) * 0.2 * b.mass,
                        y: (Math.random()-0.5) * 0.2 * b.mass
                    });
                });
            }
            lastAcc = {x:acc.x, y:acc.y};
        }

        // ==========================================
        // 5. UI 與初始化
        // ==========================================
        const inputs = {
            count: document.getElementById('input-count'),
            size: document.getElementById('input-size'),
            random: document.getElementById('input-random'),
            gravity: document.getElementById('input-gravity')
        };
        const spans = {
            count: document.getElementById('val-count'),
            size: document.getElementById('val-size'),
            random: document.getElementById('val-random'),
            gravity: document.getElementById('val-gravity')
        };

        function updateUI(k) {
            spans[k].innerText = inputs[k].value;
            config.count = parseInt(inputs.count.value);
            config.baseSize = parseInt(inputs.size.value);
            config.randomness = parseInt(inputs.random.value);
            config.gravity = parseFloat(inputs.gravity.value);

            if(k !== 'gravity') {
                clearTimeout(window.t);
                window.t = setTimeout(rebuildBalls, 100);
            }
        }

        Object.keys(inputs).forEach(k => inputs[k].addEventListener('input', () => updateUI(k)));
        document.getElementById('toggle-btn').onclick = () => document.getElementById('control-panel').classList.toggle('collapsed');

        function start() {
            document.getElementById('start-overlay').style.display = 'none';
            window.addEventListener('resize', () => {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                createWalls();
                rebuildBalls();
            });
            window.addEventListener('deviceorientation', handleOrientation);
            window.addEventListener('devicemotion', handleMotion);
            
            createWalls();
            rebuildBalls();
            render();
        }

        document.getElementById('start-btn').onclick = () => {
            initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(r=>{if(r==='granted')start()}).catch(()=>start());
            } else {
                start();
            }
        };
    </script>
</body>
</html>
