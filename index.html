<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>互動水流聲效版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #020205; /* 深海黑 */
            touch-action: none;
            font-family: 'Segoe UI', sans-serif;
        }

        /* 背景動態光影 */
        #bg-gradient {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 30%, #1a2a6c, #000000 80%);
            z-index: 0;
        }

        /* 畫布層 */
        canvas {
            display: block;
            position: absolute;
            z-index: 1;
            /* 關鍵：濾鏡讓漸層球融合 */
            filter: url('#water-filter'); 
        }

        /* UI 層 */
        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        #start-btn {
            padding: 16px 40px;
            font-size: 20px;
            color: #fff;
            background: linear-gradient(45deg, #00c6ff, #0072ff);
            border: none;
            border-radius: 50px;
            box-shadow: 0 0 20px rgba(0, 198, 255, 0.5);
            cursor: pointer;
            pointer-events: auto;
            transition: transform 0.1s;
            font-weight: bold;
            letter-spacing: 1px;
        }
        #start-btn:active {
            transform: scale(0.95);
        }

        .status-text {
            color: rgba(255,255,255,0.5);
            margin-bottom: 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="bg-gradient"></div>

    <div id="ui-layer">
        <div id="status" class="status-text">準備就緒</div>
        <button id="start-btn">開啟水流 (聲音+感測)</button>
    </div>

    <svg style="position: absolute; width:0; height:0;">
        <defs>
            <filter id="water-filter">
                <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
                <feColorMatrix in="blur" mode="matrix" values="
                    1 0 0 0 0
                    0 1 0 0 0
                    0 0 1 0 0
                    0 0 0 25 -9" result="water" />
                <feComposite in="SourceGraphic" in2="water" operator="atop"/>
            </filter>
        </defs>
    </svg>

    <canvas id="world"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // --- 1. 初始化設定 ---
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const uiLayer = document.getElementById('ui-layer');

        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // --- 2. Matter.js 物理引擎 ---
        const Engine = Matter.Engine,
              World = Matter.World,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite;

        const engine = Engine.create();
        const world = engine.world;
        
        // 建立邊界
        const walls = [];
        const wallThickness = 200;
        function createWalls() {
            Composite.clear(world, false, true); // 清除舊牆壁但保留球
            // 重新加入球 (Matter.js 的 clear 有點暴力，我們手動處理牆壁比較好，這裡簡化直接重建邊界)
            // 實際上我們只更新牆壁位置
            World.remove(world, walls);
            walls.length = 0;

            const opts = { isStatic: true, render: { visible: false } };
            walls.push(
                Bodies.rectangle(width/2, -wallThickness, width, wallThickness, opts), // 上
                Bodies.rectangle(width/2, height+wallThickness, width, wallThickness, opts), // 下
                Bodies.rectangle(width+wallThickness, height/2, wallThickness, height, opts), // 右
                Bodies.rectangle(-wallThickness, height/2, wallThickness, height, opts) // 左
            );
            World.add(world, walls);
        }
        createWalls();

        // 生成液體粒子
        const particles = [];
        const particleCount = 300; // 300 顆是效能與效果的平衡點
        const size = 12; // 粒子半徑
        
        for(let i=0; i<particleCount; i++) {
            const x = Math.random() * width;
            const y = Math.random() * height/2 + height/2;
            const p = Bodies.circle(x, y, size, {
                friction: 0.001,
                restitution: 0.5,
                density: 0.04,
                frictionAir: 0.02
            });
            particles.push(p);
        }
        World.add(world, particles);

        // --- 3. 自定義渲染 (這是畫面變漂亮的關鍵) ---
        // 我們不使用 Matter.Render，而是自己用 Canvas API 畫，這樣才能畫出「漸層球」
        function renderLoop() {
            Engine.update(engine, 1000 / 60);
            
            // 清除畫布
            ctx.clearRect(0, 0, width, height);

            // 繪製每一顆粒子
            ctx.globalCompositeOperation = 'source-over';
            
            for(let i=0; i<particles.length; i++) {
                const p = particles[i];
                const x = p.position.x;
                const y = p.position.y;

                // 建立徑向漸層：中心亮藍 -> 邊緣透明
                // 這會讓粒子看起來像發光的光點，疊加後會變得很亮
                const grad = ctx.createRadialGradient(x, y, size * 0.2, x, y, size * 1.2);
                grad.addColorStop(0, 'rgba(100, 255, 255, 1)');   // 核心亮白
                grad.addColorStop(0.5, 'rgba(0, 150, 255, 0.8)'); // 中間藍
                grad.addColorStop(1, 'rgba(0, 50, 255, 0)');      // 邊緣透明

                ctx.beginPath();
                ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();
            }
            
            // 更新音效
            updateAudio();

            requestAnimationFrame(renderLoop);
        }

        // --- 4. Web Audio API 音效系統 (合成水聲) ---
        let audioCtx;
        let noiseNode;
        let gainNode;
        let filterNode;
        let audioInitialized = false;

        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // 1. 建立白噪音緩衝區
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            // 2. 建立節點
            noiseNode = audioCtx.createBufferSource();
            noiseNode.buffer = buffer;
            noiseNode.loop = true;

            // 低通濾波器 (讓白噪音聽起來悶悶的像水聲)
            filterNode = audioCtx.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 400; // 初始頻率

            // 音量控制
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0; // 初始靜音

            // 連接：噪音 -> 濾波 -> 音量 -> 輸出
            noiseNode.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            noiseNode.start(0);
            audioInitialized = true;
        }

        // 根據粒子速度動態調整聲音
        function updateAudio() {
            if(!audioInitialized) return;

            // 計算所有粒子的平均速度
            let totalSpeed = 0;
            // 為了效能，只抽樣前 50 顆
            const sampleSize = Math.min(particles.length, 50);
            for(let i=0; i<sampleSize; i++) {
                totalSpeed += particles[i].speed;
            }
            const avgSpeed = totalSpeed / sampleSize;

            // 映射速度到音量和頻率
            // 速度越快 -> 音量越大，聲音越清脆(頻率變高)
            const targetGain = Math.min(avgSpeed * 0.1, 0.5); // 最大音量 0.5
            const targetFreq = 200 + (avgSpeed * 100); // 頻率 200Hz ~ 

            // 平滑過渡
            gainNode.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.1);
            filterNode.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.1);
        }

        // --- 5. 互動控制 ---
        startBtn.addEventListener('click', () => {
            // 啟動音效 context (瀏覽器要求必須在點擊事件中啟動)
            initAudio();
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            // 請求陀螺儀權限
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            startGame();
                        } else {
                            alert('需要權限才能體驗完整功能');
                        }
                    })
                    .catch(console.error);
            } else {
                // Android / PC
                window.addEventListener('deviceorientation', handleOrientation);
                startGame();
            }
        });

        function startGame() {
            uiLayer.style.display = 'none'; // 隱藏按鈕
            renderLoop(); // 開始渲染迴圈
        }

        // 陀螺儀邏輯 (與上一版相同，針對直立優化)
        function handleOrientation(event) {
            const gamma = event.gamma; // 左右
            const beta = event.beta;   // 前後
            
            if (gamma === null || beta === null) return;

            // 限制與平滑重力
            let gx = Math.min(Math.max(gamma / 45, -1), 1);
            let gy = Math.min(Math.max(beta / 45, -1), 1);

            engine.gravity.x = gx;
            engine.gravity.y = gy;
        }
        
        // 視窗縮放處理
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            createWalls();
        });
        
        // 讓電腦版也可以用滑鼠拖曳水
        const MouseConstraint = Matter.MouseConstraint, Mouse = Matter.Mouse;
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: Mouse.create(canvas),
            constraint: { stiffness: 0.2, render: { visible: false } }
        });
        World.add(world, mouseConstraint);

    </script>
</body>
</html>
