<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web 3D City Runner V8.0 (Modular Architecture)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #87CEEB; touch-action: none; }
        
        /* UI Layout */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; z-index: 10; }
        #score-board { padding: 20px; color: #fff; font-size: 28px; font-weight: 900; text-shadow: 2px 2px 0 #000; display: flex; justify-content: space-between; }
        #powerup-status { color: #00ff00; text-shadow: 0 0 10px #00ff00; }
        #ui-bottom { flex-grow: 1; display: flex; justify-content: center; align-items: flex-end; padding-bottom: 50px; pointer-events: none; }
        
        .message-box { background: rgba(0,0,0,0.7); color: #fff; padding: 15px 30px; border-radius: 50px; font-size: 24px; font-weight: bold; border: 2px solid #fff; animation: fadeUp 2s forwards; }
        @keyframes fadeUp { 0% { opacity: 0; transform: translateY(20px); } 20% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateY(-20px); } }

        /* Virtual Buttons */
        .control-btn { position: absolute; bottom: 40px; width: 80px; height: 80px; border-radius: 50%; color: white; font-weight: 900; font-size: 30px; display: flex; align-items: center; justify-content: center; pointer-events: auto; backdrop-filter: blur(4px); box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: transform 0.1s; }
        .control-btn:active { transform: scale(0.9); }
        #btn-fire { right: 30px; background: rgba(255, 50, 50, 0.4); border: 3px solid rgba(255, 255, 255, 0.6); font-size: 18px; }
        #btn-left { left: 30px; background: rgba(255, 255, 255, 0.2); border: 3px solid rgba(255, 255, 255, 0.5); }
        #btn-right { left: 130px; background: rgba(255, 255, 255, 0.2); border: 3px solid rgba(255, 255, 255, 0.5); }
        @media (min-width: 1024px) { .control-btn { display: none; } }

        /* Camera Preview */
        #camera-wrapper { position: absolute; top: 20px; left: 20px; width: 160px; height: 120px; background: #000; border: 2px solid #fff; border-radius: 10px; z-index: 20; display: none; overflow: hidden; pointer-events: auto; }
        #camera-video { display: none; }
        #camera-canvas { width: 100%; height: 100%; transform: scaleX(-1); }
        #face-status { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(0,0,0,0.6); color: #0f0; font-size: 10px; text-align: center; padding: 2px 0; white-space: nowrap; }

        /* Screens */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; backdrop-filter: blur(8px); z-index: 99; }
        h1 { color: #FFD700; font-size: 50px; margin: 0 0 10px 0; text-shadow: 4px 4px 0 #000; font-style: italic; letter-spacing: 3px; text-align: center; }
        .setup-panel { background: rgba(255,255,255,0.1); padding: 20px 30px; border-radius: 20px; border: 2px solid rgba(255,255,255,0.2); display: flex; flex-direction: column; gap: 20px; margin-bottom: 20px; max-width: 90%; }
        .row-group { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .select-group { display: flex; flex-direction: column; align-items: flex-start; }
        .select-group label { color: #00ffff; font-size: 14px; margin-bottom: 5px; font-weight: bold; }
        select { padding: 8px 12px; font-size: 16px; border-radius: 8px; border: none; background: #fff; cursor: pointer; outline: none; min-width: 160px; }
        button { padding: 15px 60px; font-size: 24px; cursor: pointer; background: linear-gradient(45deg, #00e5ff, #2979ff); border: 3px solid #fff; border-radius: 50px; color: white; font-weight: bold; box-shadow: 0 6px 0 #004ba0; transition: 0.1s; text-transform: uppercase; }
        button:active { transform: translateY(4px); box-shadow: 0 2px 0 #004ba0; }
        #loading-text { margin-top: 15px; color: #aaa; font-size: 13px; text-align: center; line-height: 1.6; }
    </style>
</head>
<body>

    <div id="camera-wrapper">
        <video id="camera-video"></video>
        <canvas id="camera-canvas"></canvas>
        <div id="face-status">ç­‰å¾…æ”åƒé ­...</div>
    </div>

    <div id="ui-layer">
        <div id="score-board">
            <div>SCORE: <span id="score-val">0</span> | COINS: <span id="coin-val">0</span></div>
            <div id="powerup-status">GUN: <span id="shots-val">Lv.1</span></div>
        </div>
        
        <div id="btn-left" class="control-btn">â†</div>
        <div id="btn-right" class="control-btn">â†’</div>
        <div id="btn-fire" class="control-btn">FIRE</div>

        <div id="ui-bottom"><div id="message-display"></div></div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>CITY RUNNER</h1>
        <div class="setup-panel">
            <div class="row-group">
                <div class="select-group">
                    <label>ğŸ® æ§åˆ¶æ–¹å¼</label>
                    <select id="control-mode">
                        <option value="normal">éµç›¤ / è§¸æ§ (é è¨­)</option>
                        <option value="camera">ğŸ“· é ­éƒ¨é«”æ„Ÿæ§åˆ¶ (V8.0)</option>
                    </select>
                </div>
            </div>
            <div class="row-group">
                <div class="select-group">
                    <label>ğŸƒ è§’è‰²æ¨¡å‹</label>
                    <select id="player-selector">
                        <option value="none" selected>ğŸŸ¦ ä½¿ç”¨æ–¹å¡Šäºº (æœ€é †æš¢)</option>
                        <option value="player.glb">é è¨­è§’è‰²</option>
                        <option value="player2.glb">è§’è‰² B</option>
                    </select>
                </div>
            </div>
        </div>
        <button id="btn-start">START GAME</button>
        <div id="loading-text">
            PC: [â†/â†’]ç§»å‹• | [Space]è·³èº | [Z]å°„æ“Š<br>
            Mobile: æŒ‰éˆ•æ§åˆ¶ | é›™æŒ‡ä¸Šæ»‘è·³èº<br>
            Camera: è½‰é ­(ç§»å‹•) | é–‰é›™çœ¼(è·³èº) | å¼µå˜´(å°„æ“Š)
        </div>
    </div>

    <div id="game-over-screen" class="overlay" style="display: none;">
        <h1 style="color: #ff4444;">CRASHED!</h1>
        <p style="color:white; font-size: 24px;">FINAL SCORE: <span id="final-score">0</span></p>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <script>
        class GameInputManager {
            constructor(callbacks) {
                // å›å‘¼å‡½å¼ä»‹é¢ï¼š{ onMoveLeft, onMoveRight, onJump, onFire }
                this.cbs = callbacks;
                this.mode = 'normal';
                this.lastActionTime = 0;
                this.actionCooldown = 400;
                
                // MediaPipe ç›¸é—œ
                this.faceMesh = null;
                this.camera = null;
                this.videoEl = document.getElementById('camera-video');
                this.canvasEl = document.getElementById('camera-canvas');
                this.canvasCtx = this.canvasEl.getContext('2d');
                this.statusEl = document.getElementById('face-status');
                this.previewEl = document.getElementById('camera-wrapper');

                // ç‹€æ…‹æ¨™è¨˜
                this.isActive = false;
            }

            // åˆå§‹åŒ–æ‰€æœ‰è¼¸å…¥ç›£è½
            init() {
                this._initKeyboard();
                this._initTouch();
                this._initVirtualButtons();
            }

            setMode(mode) {
                this.mode = mode;
                if (mode === 'camera') {
                    this._startCamera();
                    this._toggleVirtualButtons(false);
                } else {
                    this._toggleVirtualButtons(window.innerWidth < 1024);
                }
                this.isActive = true;
            }

            // --- å…§éƒ¨æ–¹æ³•: éµç›¤ ---
            _initKeyboard() {
                document.addEventListener('keydown', (e) => {
                    if (!this.isActive) return;
                    if (e.key === 'ArrowLeft') this.cbs.onMoveLeft();
                    if (e.key === 'ArrowRight') this.cbs.onMoveRight();
                    if (e.key === 'ArrowUp' || e.code === 'Space') this.cbs.onJump();
                    if (e.key === 'z' || e.key === 'Z') this.cbs.onFire();
                });
            }

            // --- å…§éƒ¨æ–¹æ³•: è§¸æ§ (Swipe) ---
            _initTouch() {
                let startX = 0, startY = 0;
                document.addEventListener('touchstart', (e) => {
                    startX = e.changedTouches[0].screenX;
                    startY = e.changedTouches[0].screenY;
                }, {passive: false});

                document.addEventListener('touchend', (e) => {
                    if (!this.isActive) return;
                    const yDiff = e.changedTouches[0].screenY - startY;
                    // ä¸Šæ»‘è·³èº
                    if (Math.abs(yDiff) > 30 && yDiff < 0) this.cbs.onJump();
                }, {passive: false});
            }

            // --- å…§éƒ¨æ–¹æ³•: è™›æ“¬æŒ‰éˆ• ---
            _initVirtualButtons() {
                document.getElementById('btn-left').onclick = () => this.cbs.onMoveLeft();
                document.getElementById('btn-right').onclick = () => this.cbs.onMoveRight();
                document.getElementById('btn-fire').onclick = () => this.cbs.onFire();
            }

            _toggleVirtualButtons(show) {
                const display = show ? 'flex' : 'none';
                document.querySelectorAll('.control-btn').forEach(el => el.style.display = display);
            }

            // --- å…§éƒ¨æ–¹æ³•: æ”åƒé ­èˆ‡ MediaPipe ---
            async _startCamera() {
                this.statusEl.innerText = "å•Ÿå‹•æ”åƒé ­...";
                this.previewEl.style.display = 'block';
                
                this.faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
                this.faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                this.faceMesh.onResults(this._onFaceResults.bind(this)); // ç¶å®š this

                if(typeof Camera !== 'undefined') {
                    this.camera = new Camera(this.videoEl, {
                        onFrame: async () => { await this.faceMesh.send({image: this.videoEl}); },
                        width: 320, height: 240
                    });
                    await this.camera.start();
                } else {
                    alert("ç„¡æ³•è¼‰å…¥ç›¸æ©Ÿåº«");
                }
            }

            _onFaceResults(results) {
                // ç¹ªè£½é™¤éŒ¯ç•«é¢
                this.canvasCtx.save();
                this.canvasCtx.clearRect(0, 0, this.canvasEl.width, this.canvasEl.height);
                this.canvasCtx.drawImage(results.image, 0, 0, this.canvasEl.width, this.canvasEl.height);
                
                if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                    const landmarks = results.multiFaceLandmarks[0];
                    drawConnectors(this.canvasCtx, landmarks, FACEMESH_TESSELATION, {color: '#C0C0C050', lineWidth: 0.5});
                    this._processFaceLogic(landmarks);
                } else {
                    this.statusEl.innerText = "æœªåµæ¸¬åˆ°è‡‰éƒ¨";
                }
                this.canvasCtx.restore();
            }

            _processFaceLogic(landmarks) {
                const now = Date.now();
                
                // 1. è½‰é ­ (Yaw)
                const rightSide = landmarks[234]; 
                const leftSide = landmarks[454];
                const nose = landmarks[1];
                const faceWidth = Math.abs(leftSide.x - rightSide.x);
                const faceCenter = (leftSide.x + rightSide.x) / 2;
                const turnVal = (nose.x - faceCenter) / faceWidth;
                const turnThreshold = 0.12;

                // 2. é–‰çœ¼ (Double Blink)
                const leftEyeOpen = Math.abs(landmarks[159].y - landmarks[145].y);
                const rightEyeOpen = Math.abs(landmarks[386].y - landmarks[374].y);
                const blinkThreshold = 0.012;

                // 3. å¼µå˜´ (Mouth)
                const mouthOpen = Math.abs(landmarks[13].y - landmarks[14].y);
                const mouthThreshold = 0.05;

                // A. å°„æ“Š
                if (mouthOpen > mouthThreshold) {
                    if (now - this.lastActionTime > 200) {
                        this.cbs.onFire();
                        this.statusEl.innerText = "ğŸ”¥ å¼µå˜´å°„æ“Š!";
                        this.lastActionTime = now;
                    }
                    return;
                }

                // B. è·³èº
                if (leftEyeOpen < blinkThreshold && rightEyeOpen < blinkThreshold) {
                    if (now - this.lastActionTime > 500) { // è·³èºå†·å»ç¨é•·
                        this.cbs.onJump();
                        this.statusEl.innerText = "ğŸ˜Œ é–‰çœ¼è·³èº!";
                        this.lastActionTime = now;
                    }
                    return;
                }

                // C. ç§»å‹•
                if (now - this.lastActionTime > this.actionCooldown) {
                    if (turnVal < -turnThreshold) { // å¾€å³
                        this.cbs.onMoveRight();
                        this.statusEl.innerText = "â¡ï¸ é ­è½‰å³";
                        this.lastActionTime = now;
                    } else if (turnVal > turnThreshold) { // å¾€å·¦
                        this.cbs.onMoveLeft();
                        this.statusEl.innerText = "â¬…ï¸ é ­è½‰å·¦";
                        this.lastActionTime = now;
                    } else {
                        this.statusEl.innerText = "ğŸ‘€ åµæ¸¬ä¸­...";
                    }
                }
            }
        }
    </script>

    <script>
        // --- éŠæˆ²å…¨åŸŸè®Šæ•¸ ---
        let gameActive = false;
        let currentLane = 0; 
        let isJumping = false; 
        let jumpVelocity = 0;
        const gravity = -0.03; 
        const jumpStrength = 0.6;
        let score = 0; 
        let gameSpeed = 0.4;
        let shotsPerFire = 1;

        // --- Three.js åˆå§‹åŒ– ---
        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 30, 120);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 400);
        camera.position.set(0, 3.5, 8); camera.lookAt(0, 1, -10);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ç‡ˆå…‰
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -50; dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50; dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // --- éŠæˆ²ç‰©ä»¶ ---
        const road = new THREE.Mesh(new THREE.PlaneGeometry(14, 1000), new THREE.MeshPhongMaterial({ color: 0x333333 }));
        road.rotation.x = -Math.PI / 2; road.position.z = -400; road.receiveShadow = true; scene.add(road);

        const playerGroup = new THREE.Group(); scene.add(playerGroup);
        const obstacles = [], coins = [], powerups = [], bullets = [], stripes = [], buildings = [], clouds = [];
        
        // ç‰©ä»¶æ± èˆ‡è³‡æºè¼‰å…¥ (ç°¡åŒ–ç‰ˆ)
        const loader = new THREE.GLTFLoader();
        let coinModel, powerupModel, obstacleModel;
        const ts = new Date().getTime();
        loader.load('coin.glb?v='+ts, (g) => { coinModel = g.scene; coinModel.traverse(n=>{if(n.isMesh){n.castShadow=true; n.material.color.setHex(0xFFD700);}}); });
        loader.load('powerup.glb?v='+ts, (g) => { powerupModel = g.scene; powerupModel.traverse(n=>{if(n.isMesh){n.castShadow=true; n.material.color.setHex(0x00FF00);}}); });
        
        // é å…ˆç”Ÿæˆç’°å¢ƒ
        for(let i=0; i<30; i++) {
            const s = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 4), new THREE.MeshBasicMaterial({ color: 0xffffff }));
            s.rotation.x = -Math.PI/2; s.position.set(-2.5, 0.02, -i*10); scene.add(s); stripes.push(s);
            const s2 = s.clone(); s2.position.set(2.5, 0.02, -i*10); scene.add(s2); stripes.push(s2);
        }
        // (é€™è£¡çœç•¥å»ºç¯‰ç‰©èˆ‡é›²çš„ç”Ÿæˆä»£ç¢¼ä»¥ä¿æŒç°¡æ½”ï¼Œé‚è¼¯åŒå‰ç‰ˆ)

        // --- éŸ³æ•ˆç³»çµ± ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(freq, type, duration, vol) {
            if(freq <= 0) return;
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        }
        function playSFX(type) {
            if(type==='jump') playTone(400,'sine',0.3,0.1);
            if(type==='shoot') playTone(800,'square',0.05,0.05);
            if(type==='coin') playTone(1500,'square',0.1,0.05);
            if(type==='crash') playTone(60,'sawtooth',0.6,0.2);
        }

        // --- éŠæˆ²å‹•ä½œ (Actions) ---
        const actions = {
            onMoveLeft: () => { if(gameActive && currentLane > -1) currentLane--; },
            onMoveRight: () => { if(gameActive && currentLane < 1) currentLane++; },
            onJump: () => { 
                if(gameActive && !isJumping) { 
                    isJumping = true; jumpVelocity = jumpStrength; playSFX('jump'); 
                } 
            },
            onFire: () => {
                if(!gameActive) return;
                playSFX('shoot');
                const spread = shotsPerFire > 1 ? (shotsPerFire - 1) * 0.5 : 0;
                for (let i = 0; i < shotsPerFire; i++) {
                    const b = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
                    const startX = playerGroup.position.x - spread / 2 + (i * (spread / (shotsPerFire > 1 ? shotsPerFire - 1 : 1)));
                    b.position.set(startX, playerGroup.position.y + 0.5, playerGroup.position.z);
                    scene.add(b); bullets.push(b);
                }
            }
        };

        // --- åˆå§‹åŒ– Input Manager ---
        const inputManager = new GameInputManager(actions);
        inputManager.init(); // å•Ÿå‹•ç›£è½

        // --- éŠæˆ²æµç¨‹ ---
        function loadPlayer(val) {
            playerGroup.clear();
            if(val === 'none') {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1.5,1), new THREE.MeshPhongMaterial({color: 0x00ffcc}));
                mesh.position.y = 0.75; mesh.castShadow = true; playerGroup.add(mesh);
            } else {
                loader.load(val, (g) => { 
                    const m = g.scene; m.scale.set(0.8,0.8,0.8); m.rotation.y = Math.PI; 
                    m.traverse(n=>{if(n.isMesh)n.castShadow=true;}); playerGroup.add(m); 
                });
            }
        }

        function loadObstacle(val) {
             if(val !== 'none') loader.load(val, (g)=>{ obstacleModel = g.scene; obstacleModel.traverse(n=>{if(n.isMesh)n.castShadow=true;}); });
        }

        document.getElementById('btn-start').onclick = () => {
            const mode = document.getElementById('control-mode').value;
            inputManager.setMode(mode); // è¨­å®šè¼¸å…¥æ¨¡å¼
            
            loadPlayer(document.getElementById('player-selector').value);
            loadObstacle(document.getElementById('obstacle-selector').value);
            
            document.getElementById('start-screen').style.display = 'none';
            gameActive = true; 
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            // é–‹å§‹ç”Ÿæˆç‰©ä»¶
            setInterval(spawnObject, 1000);
            setInterval(()=>{ if(gameActive && gameSpeed < 1.8) gameSpeed += 0.002; }, 1000);
            animate();
        };

        function spawnObject() {
            if(!gameActive) return;
            const lane = Math.floor(Math.random()*3)-1; const zPos = -120; const rnd = Math.random();
            if(rnd < 0.6) {
                let obs = obstacleModel ? obstacleModel.clone() : new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshPhongMaterial({color:0xff4444}));
                obs.position.set(lane*2.5, 1, zPos); scene.add(obs); obstacles.push(obs);
            } else if (rnd < 0.9) {
                let c = coinModel ? coinModel.clone() : new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,0.1,16), new THREE.MeshPhongMaterial({color:0xffff00}));
                if(!coinModel) c.rotation.x = Math.PI/2;
                c.position.set(lane*2.5, 1, zPos); c.userData={active:true}; scene.add(c); coins.push(c);
            } else {
                let p = powerupModel ? powerupModel.clone() : new THREE.Mesh(new THREE.SphereGeometry(0.7), new THREE.MeshPhongMaterial({color:0x00ff00}));
                p.position.set(lane*2.5, 1, zPos); p.userData={active:true}; scene.add(p); powerups.push(p);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // ç’°å¢ƒæ²å‹•
            stripes.forEach(s => { s.position.z += gameSpeed; if(s.position.z > 10) s.position.z = -290; });

            if(!gameActive) return;

            // è§’è‰²ç‰©ç†
            playerGroup.position.x += (currentLane*2.5 - playerGroup.position.x) * 0.15;
            if(isJumping) { 
                playerGroup.position.y += jumpVelocity; jumpVelocity += gravity; 
                if(playerGroup.position.y<=0) { playerGroup.position.y=0; isJumping=false; } 
            }

            // å­å½ˆé‚è¼¯
            for(let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i]; b.position.z -= 1.5;
                for(let j=obstacles.length-1; j>=0; j--) {
                    if(b.position.distanceTo(obstacles[j].position) < 1.8) {
                        scene.remove(b); bullets.splice(i,1);
                        scene.remove(obstacles[j]); obstacles.splice(j,1);
                        score+=100; document.getElementById('score-val').innerText = score;
                        break; 
                    }
                }
                if(b && b.position.z < -100) { scene.remove(b); bullets.splice(i,1); }
            }

            // éšœç¤™ç‰©é‚è¼¯
            for(let i=obstacles.length-1; i>=0; i--) {
                obstacles[i].position.z += gameSpeed;
                if(Math.abs(obstacles[i].position.z - playerGroup.position.z)<1.5 && Math.abs(obstacles[i].position.x - playerGroup.position.x)<1.0 && playerGroup.position.y < 1.5) {
                    gameActive = false; playSFX('crash');
                    document.getElementById('final-score').innerText = score;
                    document.getElementById('game-over-screen').style.display = 'flex';
                }
                if(obstacles[i].position.z > 10) { scene.remove(obstacles[i]); obstacles.splice(i,1); score+=10; document.getElementById('score-val').innerText=score; }
            }

            // é‡‘å¹£é‚è¼¯
            coins.forEach((c, i) => {
                c.position.z += gameSpeed; c.rotation.y += 0.1;
                if(c.userData.active && c.position.distanceTo(playerGroup.position) < 1.5) {
                    c.userData.active = false; scene.remove(c); coins.splice(i,1);
                    score+=50; document.getElementById('score-val').innerText = score; playSFX('coin');
                }
            });

            // é“å…·é‚è¼¯
            powerups.forEach((p, i) => {
                p.position.z += gameSpeed;
                if(p.userData.active && p.position.distanceTo(playerGroup.position) < 1.5) {
                    p.userData.active = false; scene.remove(p); powerups.splice(i,1);
                    playSFX('powerup'); shotsPerFire = 3; document.getElementById('shots-val').innerText = "Lv.MAX";
                    setTimeout(()=>{ shotsPerFire=1; document.getElementById('shots-val').innerText = "Lv.1"; }, 10000);
                }
            });
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
