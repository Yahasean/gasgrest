<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>深海氣泡 400</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a2a6c, #000000); /* 深海藍黑漸層 */
            touch-action: none;
            font-family: sans-serif;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            width: 100%;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 18px;
            color: #fff;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 30px;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .status {
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 15px;
            font-size: 14px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="status">傾斜流動 • 搖晃炸裂</div>
        <button id="start-btn">進入深海 (啟動)</button>
    </div>

    <canvas id="world"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        const canvas = document.getElementById('world');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('start-btn');
        const uiLayer = document.getElementById('ui-layer');

        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // --- Matter.js 設定 ---
        const Engine = Matter.Engine,
              World = Matter.World,
              Bodies = Matter.Bodies,
              Body = Matter.Body,
              Composite = Matter.Composite;

        const engine = Engine.create();
        const world = engine.world;
        
        // 物理球體陣列
        const balls = [];
        
        // 背景裝飾氣泡陣列 (不參與物理碰撞，純視覺)
        const bgBubbles = [];

        // 顏色庫 (海洋色系)
        const colors = ['#4facfe', '#00f2fe', '#00c6fb', '#005bea', '#ffffff'];

        // --- 1. 初始化物理世界 ---
        function initPhysics() {
            // 建立邊界
            const wallThick = 100;
            const walls = [
                Bodies.rectangle(width/2, -wallThick, width, wallThick, { isStatic: true }),
                Bodies.rectangle(width/2, height+wallThick, width, wallThick, { isStatic: true }),
                Bodies.rectangle(width+wallThick, height/2, wallThick, height, { isStatic: true }),
                Bodies.rectangle(-wallThick, height/2, wallThick, height, { isStatic: true })
            ];
            World.add(world, walls);

            // 建立 400 顆球
            const ballCount = 400;
            for(let i = 0; i < ballCount; i++) {
                const radius = Math.random() * 6 + 4; // 半徑 4~10 (稍微小一點以免太擠)
                const x = Math.random() * width;
                const y = Math.random() * height;
                
                const ball = Bodies.circle(x, y, radius, {
                    restitution: 0.5, // 彈性
                    friction: 0.001,
                    frictionAir: 0.01, // 稍微有點空氣阻力，像在水裡
                    render: {
                        fillStyle: colors[Math.floor(Math.random() * colors.length)]
                    }
                });
                balls.push(ball);
            }
            World.add(world, balls);
        }

        // --- 2. 初始化背景氣泡 (視覺特效) ---
        function initBgBubbles() {
            for(let i = 0; i < 50; i++) { // 50顆背景氣泡
                bgBubbles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    radius: Math.random() * 3 + 1,
                    speed: Math.random() * 1 + 0.5, // 上升速度
                    wobble: Math.random() * Math.PI * 2 // 搖擺相位
                });
            }
        }

        // --- 3. 渲染循環 (手動繪製以求最高效能) ---
        function render() {
            Engine.update(engine, 1000 / 60);
            
            ctx.clearRect(0, 0, width, height);

            // A. 繪製背景氣泡 (緩緩上升)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; // 極淡的白色
            bgBubbles.forEach(b => {
                // 更新位置
                b.y -= b.speed;
                b.x += Math.sin(b.y * 0.05 + b.wobble) * 0.5; // 左右輕微搖擺

                // 超出頂部重置到底部
                if(b.y < -10) {
                    b.y = height + 10;
                    b.x = Math.random() * width;
                }

                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // B. 繪製物理球體 (核心)
            // 為了效能，我們不切換 fillStyle 太多次，這裡簡單繪製
            for(let i = 0; i < balls.length; i++) {
                const b = balls[i];
                
                ctx.beginPath();
                ctx.arc(b.position.x, b.position.y, b.circleRadius, 0, Math.PI * 2);
                // 直接讀取我們存在 body.render 裡的顏色
                ctx.fillStyle = b.render.fillStyle; 
                ctx.fill();
            }

            requestAnimationFrame(render);
        }

        // --- 4. 互動控制 (傾斜 + 搖晃) ---
        let lastX = 0, lastY = 0, lastZ = 0;
        let shakeThreshold = 20; // 搖晃靈敏度 (數值越小越靈敏)

        function handleMotion(event) {
            // A. 重力 (傾斜) - 使用 deviceorientation (更平滑的重力方向)
            // 不在這裡處理，獨立監聽 deviceorientation
            
            // B. 搖晃偵測 (Shake) - 使用 devicemotion (加速度)
            const acc = event.accelerationIncludingGravity; // 包含重力的加速度
            if(!acc) return;

            const deltaX = Math.abs(acc.x - lastX);
            const deltaY = Math.abs(acc.y - lastY);
            const deltaZ = Math.abs(acc.z - lastZ);

            if ((deltaX + deltaY + deltaZ) > shakeThreshold) {
                triggerShakeEffect();
            }

            lastX = acc.x;
            lastY = acc.y;
            lastZ = acc.z;
        }

        function triggerShakeEffect() {
            // 搖晃時：給所有球一個隨機的強力衝擊
            balls.forEach(b => {
                Body.applyForce(b, b.position, {
                    x: (Math.random() - 0.5) * 0.02 * b.mass, 
                    y: (Math.random() - 0.5) * 0.02 * b.mass
                });
            });
        }

        function handleOrientation(event) {
            // 簡單的重力映射
            const gamma = event.gamma; // 左右
            const beta = event.beta;   // 前後

            if (gamma == null || beta == null) return;

            // 限制範圍並平滑化
            const gx = Math.min(Math.max(gamma / 45, -1), 1);
            const gy = Math.min(Math.max(beta / 45, -1), 1);

            engine.gravity.x = gx;
            engine.gravity.y = gy;
        }

        // --- 啟動流程 ---
        startBtn.addEventListener('click', () => {
            // 權限請求 (iOS 13+)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            window.addEventListener('devicemotion', handleMotion); // 增加 motion 監聽 shake
                            startGame();
                        } else {
                            alert('需要感測器權限');
                        }
                    })
                    .catch(console.error);
            } else {
                // Android / PC
                window.addEventListener('deviceorientation', handleOrientation);
                window.addEventListener('devicemotion', handleMotion);
                startGame();
            }
        });

        function startGame() {
            uiLayer.style.display = 'none';
            initPhysics();
            initBgBubbles();
            render();
        }

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            // 重新調整邊界比較複雜，這裡簡單處理：重整頁面最安全，或是讓邊界稍微大一點
        });

    </script>
</body>
</html>
